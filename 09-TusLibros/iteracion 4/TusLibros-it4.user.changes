

----STARTUP---- (15 June 2023 20:46:49) as /home/jt/files/cuis-university/images/TusLibros-it4.image!


----End fileIn of /home/jt/files/cuis-university/images/TusLibros-Model Ejercicio it4.st----!

----End fileIn of /home/jt/files/cuis-university/images/TusLibrosREST Ejercicio it4.st----!

----End fileIn of /home/jt/files/cuis-university/images/TusLibros-Tests Ejercicio it4.st----!

----End fileIn of /home/jt/files/cuis-university/linux64/Packages/System/Collections-CompactArrays.pck.st----!

----End fileIn of /home/jt/files/cuis-university/linux64/Packages/Features/Compression.pck.st----!

----End fileIn of /home/jt/files/cuis-university/linux64/Packages/Features/Sound.pck.st----!

----End fileIn of /home/jt/files/cuis-university/linux64/Packages/Features/Cryptography-DigitalSignatures.pck.st----!

----End fileIn of /home/jt/files/cuis-university/linux64/Packages/Features/Identities-UUID.pck.st----!

----End fileIn of /home/jt/files/cuis-university/linux64/Packages/System/Network-Kernel.pck.st----!

----End fileIn of /home/jt/files/cuis-university/linux64/Packages/Features/WebClient.pck.st----!

----QUIT----(15 June 2023 21:01:18) TusLibros-it4.image priorSource: 9369961!

----STARTUP---- (16 June 2023 13:42:00) as /home/jt/files/cuis-university/images/TusLibros-it4.image!


!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JT 6/16/2023 14:49:43'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JT 6/16/2023 14:49:43'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JT 6/16/2023 14:49:43'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JT 6/16/2023 14:49:43'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JT 6/16/2023 14:49:43'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JT 6/16/2023 14:49:43'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JT 6/16/2023 14:49:43'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JT 6/16/2023 14:49:43'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'JT 6/16/2023 14:49:44'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'JT 6/16/2023 14:49:44'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'JT 6/16/2023 14:49:44'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'JT 6/16/2023 14:49:44'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'JT 6/16/2023 14:49:44'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'JT 6/16/2023 14:49:44'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'JT 6/16/2023 15:03:33'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 15:03:35'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 15:03:37'!
FAILURE!

----QUIT----(16 June 2023 15:37:26) TusLibros-it4.image priorSource: 10636979!

----STARTUP---- (16 June 2023 15:38:50) as /home/jt/files/cuis-university/images/TusLibros-it4.image!

!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 15:47:51' prior: 50625370!
totalSalesOf: anItem
	
	| totalSales totalSalesAccess |
	(Delay forSeconds: 1) wait.

	totalSalesAccess := Semaphore forMutualExclusion.
	totalSales := 0.

	"^salesBook sum: [:aSale | | quantityPerItem | 
		quantityPerItem := 0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
		quantityPerItem]."
	
	salesBook do: [:aSale | 
		[ | quantityPerItem | 
			quantityPerItem := 0.
			aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
			totalSalesAccess critical: [ totalSales := totalSales + quantityPerItem ]
		] fork
	].

	^ totalSales.! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 15:47:58' prior: 50664193!
totalSalesOf: anItem
	
	| totalSales totalSalesAccess |
	(Delay forSeconds: 1) wait.

	totalSalesAccess := Semaphore forMutualExclusion.
	totalSales := 0.
	
	salesBook do: [:aSale | 
		[ | quantityPerItem | 
			quantityPerItem := 0.
			aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
			totalSalesAccess critical: [ totalSales := totalSales + quantityPerItem ]
		] fork
	].

	^ totalSales.

	"^salesBook sum: [:aSale | | quantityPerItem | 
		quantityPerItem := 0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
		quantityPerItem]."! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 15:51:53' prior: 50664218!
totalSalesOf: anItem
	
	| totalSales totalSalesAccess barrier |
	(Delay forSeconds: 1) wait.

	barrier := Semaphore new.
	salesBook size timesRepeat: [ barrier signal ].
	
	totalSalesAccess := Semaphore forMutualExclusion.
	totalSales := 0.
	
	salesBook do: [:aSale | 
		[ | quantityPerItem | 
			quantityPerItem := 0.
			aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
			totalSalesAccess critical: [ totalSales := totalSales + quantityPerItem ]
		] fork
	].

	^ totalSales.

	"^salesBook sum: [:aSale | | quantityPerItem | 
		quantityPerItem := 0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
		quantityPerItem]."! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 15:52:34' prior: 50664243!
totalSalesOf: anItem
	
	| totalSales totalSalesAccess barrier numberOfWorkers |
	(Delay forSeconds: 1) wait.

	barrier := Semaphore new.
	numberOfWorkers := salesBook size.
	
	numberOfWorkers timesRepeat: [ barrier signal ].
	
	totalSalesAccess := Semaphore forMutualExclusion.
	totalSales := 0.
	
	salesBook do: [:aSale | 
		[ | quantityPerItem | 
			quantityPerItem := 0.
			aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
			totalSalesAccess critical: [ totalSales := totalSales + quantityPerItem ]
		] fork
	].

	numberOfWorkers timesRepeat: [ barrier wait ].

	^ totalSales.

	"^salesBook sum: [:aSale | | quantityPerItem | 
		quantityPerItem := 0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
		quantityPerItem]."! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 15:53:03' prior: 50664271!
totalSalesOf: anItem
	
	| totalSales totalSalesAccess barrier numberOfWorkers |
	(Delay forSeconds: 1) wait.

	totalSalesAccess := Semaphore forMutualExclusion.
	totalSales := 0.
	barrier := Semaphore new.
	numberOfWorkers := salesBook size.
	
	numberOfWorkers timesRepeat: [ barrier signal ].
	
	
	salesBook do: [:aSale | 
		[ | quantityPerItem | 
			quantityPerItem := 0.
			aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
			totalSalesAccess critical: [ totalSales := totalSales + quantityPerItem ]
		] fork
	].

	numberOfWorkers timesRepeat: [ barrier wait ].

	^ totalSales.

	"^salesBook sum: [:aSale | | quantityPerItem | 
		quantityPerItem := 0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
		quantityPerItem]."! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 15:53:05' prior: 50664302!
totalSalesOf: anItem
	
	| totalSales totalSalesAccess barrier numberOfWorkers |
	(Delay forSeconds: 1) wait.

	totalSalesAccess := Semaphore forMutualExclusion.
	totalSales := 0.
	barrier := Semaphore new.
	numberOfWorkers := salesBook size.
	
	numberOfWorkers timesRepeat: [ barrier signal ].
	
	salesBook do: [:aSale | 
		[ | quantityPerItem | 
			quantityPerItem := 0.
			aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
			totalSalesAccess critical: [ totalSales := totalSales + quantityPerItem ]
		] fork
	].

	numberOfWorkers timesRepeat: [ barrier wait ].

	^ totalSales.

	"^salesBook sum: [:aSale | | quantityPerItem | 
		quantityPerItem := 0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
		quantityPerItem]."! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 15:53:37' prior: 50664333!
totalSalesOf: anItem
	
	| totalSales totalSalesAccess barrier numberOfWorkers |
	(Delay forSeconds: 1) wait.

	totalSalesAccess := Semaphore forMutualExclusion.
	totalSales := 0.
	barrier := Semaphore new.
	numberOfWorkers := salesBook size.
	
	salesBook do: [:aSale | 
		[ | quantityPerItem | 
			quantityPerItem := 0.
			aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
			totalSalesAccess critical: [ totalSales := totalSales + quantityPerItem ].
			barrier signal.
		] fork
	].

	numberOfWorkers timesRepeat: [ barrier wait ].

	^ totalSales.

	"^salesBook sum: [:aSale | | quantityPerItem | 
		quantityPerItem := 0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
		quantityPerItem]."! !

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 15:53:52'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 15:53:54'!
FAILURE!
!TusLibrosSystemFacadeTest methodsFor: 'tests - performance' stamp: 'JT 6/16/2023 15:55:48' prior: 50626587!
test20BookPerformanceShouldNotTakeTooLong

	| cartId bookPerformance quantity total |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 2 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
		
	cartId := systemFacade createCartFor: self anotherValidUser authenticatedWith: self anotherValidUserPassword.
	systemFacade add: 5 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
		
	bookPerformance := systemFacade bookPerformance: self validBook.
	"self should: [bookPerformance := systemFacade bookPerformance: self validBook ] 
		notTakeMoreThanMilliseconds: 1100.	"

	quantity := bookPerformance at: 'quantity'.
	total := bookPerformance at: 'total'.
	self assert: 7 equals: quantity.
	self assert: (testObjectsFactory itemSellByTheStorePrice * 7) equals: total.
	self assert: 
		self validBook,' was selled ',quantity asString, ' times and raised a total amount of money equal to: ', total asString
		equals: (bookPerformance at: 'summary')
	! !

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 15:55:51'!
PASSED!
!TusLibrosSystemFacadeTest methodsFor: 'tests - performance' stamp: 'JT 6/16/2023 15:56:33' prior: 50664402!
test20BookPerformanceShouldNotTakeTooLong

	| cartId bookPerformance quantity total |

	cartId := systemFacade createCartFor: self validUser authenticatedWith: self validUserPassword.
	systemFacade add: 2 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.
		
	cartId := systemFacade createCartFor: self anotherValidUser authenticatedWith: self anotherValidUserPassword.
	systemFacade add: 5 of: self validBook toCartIdentifiedAs: cartId.
	systemFacade 
		checkOutCartIdentifiedAs: cartId 
		withCreditCardNumbered: testObjectsFactory validCreditCardNumber 
		ownedBy: testObjectsFactory validOwnerName 
		expiringOn: testObjectsFactory notExpiredMonthOfYear.

	self should: [bookPerformance := systemFacade bookPerformance: self validBook ] 
		notTakeMoreThanMilliseconds: 1100.	

	quantity := bookPerformance at: 'quantity'.
	total := bookPerformance at: 'total'.
	self assert: 7 equals: quantity.
	self assert: (testObjectsFactory itemSellByTheStorePrice * 7) equals: total.
	self assert: 
		self validBook,' was selled ',quantity asString, ' times and raised a total amount of money equal to: ', total asString
		equals: (bookPerformance at: 'summary')
	! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:03:24' prior: 50625349!
totalMoneyRaisedBy: anItem
	
	| access barrier numberOfWorkers totalMoneyRaised |
	(Delay forSeconds: 1) wait.
	
	access := Semaphore forMutualExclusion.
	totalMoneyRaised := 0.
	barrier := Semaphore new.
	numberOfWorkers := salesBook size.
	
	salesBook do: [:aSale | 
		[ | totalPerItem |
			totalPerItem :=0.
			aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [totalPerItem := totalPerItem + aLineItem total]].
			
			access critical: [ totalMoneyRaised := totalMoneyRaised + totalPerItem ].
			barrier signal
		] fork
	].

	"^salesBook sum: [:aSale | | totalPerItem |
		totalPerItem :=0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [totalPerItem := totalPerItem + aLineItem total]].
		totalPerItem]."
	
	numberOfWorkers timesRepeat: [barrier wait].
	
	^ totalMoneyRaised! !

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:04:39'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:04:41'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:04:46'!
FAILURE!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:04:48'!
FAILURE!

aBlock timeToRun!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'NR 6/13/2022 07:15:41' prior: 50664501!
totalMoneyRaisedBy: anItem
	
	(Delay forSeconds: 1) wait.

	^salesBook sum: [:aSale | | totalPerItem |
		totalPerItem :=0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [totalPerItem := totalPerItem + aLineItem total]].
		totalPerItem].
	
	! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'NR 6/13/2022 07:15:27' prior: 50664364!
totalSalesOf: anItem
	
	(Delay forSeconds: 1) wait.

	^salesBook sum: [:aSale | | quantityPerItem | 
		quantityPerItem := 0.
		aSale lineItemsDo: [:aLineItem | (aLineItem item = anItem) ifTrue: [quantityPerItem := quantityPerItem + aLineItem quantity]].
		quantityPerItem].

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:07:25' prior: 50625285!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales jobsDone result |

	bookPerformance := Dictionary new.
	
	jobsDone := Semaphore new.
	
	totalSales := [ result := self totalSalesOf: anItem. jobsDone signal. result ] fork.
	totalMoney := [ result := self totalMoneyRaisedBy: anItem. jobsDone signal. result ] fork.
	
	2 timesRepeat: [ jobsDone wait ].
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:07:40' prior: 50664570!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales jobsDone |

	bookPerformance := Dictionary new.
	
	jobsDone := Semaphore new.
	
	totalSales := [ |result| result := self totalSalesOf: anItem. jobsDone signal. result ] fork.
	totalMoney := [ |result| result := self totalMoneyRaisedBy: anItem. jobsDone signal. result ] fork.
	
	2 timesRepeat: [ jobsDone wait ].
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:08:40' prior: 50664594!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales jobsDone |

	bookPerformance := Dictionary new.
	
	jobsDone := Semaphore new.
	
	[ totalSales := self totalSalesOf: anItem. jobsDone signal ] fork.
	[ |result| totalMoney := self totalMoneyRaisedBy: anItem. jobsDone signal ] fork.
	
	2 timesRepeat: [ jobsDone wait ].
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:08:44' prior: 50664618!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales jobsDone |

	bookPerformance := Dictionary new.
	
	jobsDone := Semaphore new.
	
	[ totalSales := self totalSalesOf: anItem. jobsDone signal ] fork.
	[ totalMoney := self totalMoneyRaisedBy: anItem. jobsDone signal ] fork.
	
	2 timesRepeat: [ jobsDone wait ].
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:08:58'!
PASSED!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:10:08' prior: 50625326!
storePerformance

	| totalMoney totalSales performance jobsDone |
	
	performance := Dictionary new.
	
	
	jobsDone := Semaphore new.
	
	[ totalSales := self totalSales. jobsDone signal ] fork.
	[ totalMoney := self totalMoneyRaised. jobsDone signal ] fork.
	
	2 timesRepeat: [ jobsDone wait ].
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:10:12' prior: 50664667!
storePerformance

	| totalMoney totalSales performance jobsDone |
	
	performance := Dictionary new.
	jobsDone := Semaphore new.
	
	[ totalSales := self totalSales. jobsDone signal ] fork.
	[ totalMoney := self totalMoneyRaised. jobsDone signal ] fork.
	
	2 timesRepeat: [ jobsDone wait ].
	
	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:10:24'!
PASSED!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'JT 6/16/2023 16:15:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:15:57'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:15:58'!
PASSED!
!TusLibrosSystemFacade methodsFor: 'nil' stamp: 'JT 6/16/2023 16:23:41'!
runAndWaitAll: aCollectionOfBlocks

	| blocksSemaphore numberOfBlocks |
	blocksSemaphore := Semaphore new.
	numberOfBlocks := aCollectionOfBlocks size.
	
	aCollectionOfBlocks do: [:aBlock | [ aBlock value. blocksSemaphore signal] fork ].
	
	numberOfBlocks timesRepeat: [ blocksSemaphore wait ].! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'JT 6/16/2023 16:24:00' prior: 50664860!
runAndWaitAll: aCollectionOfBlocks

	| blocksCompleted numberOfBlocks |
	blocksCompleted := Semaphore new.
	numberOfBlocks := aCollectionOfBlocks size.
	
	aCollectionOfBlocks do: [:aBlock | [ aBlock value. blocksCompleted signal] fork ].
	
	numberOfBlocks timesRepeat: [ blocksCompleted wait ].! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'JT 6/16/2023 16:24:08' prior: 50664873!
runAndWaitAll: aCollectionOfBlocks

	| blockCompleted numberOfBlocks |
	blockCompleted := Semaphore new.
	numberOfBlocks := aCollectionOfBlocks size.
	
	aCollectionOfBlocks do: [:aBlock | [ aBlock value. blockCompleted signal] fork ].
	
	numberOfBlocks timesRepeat: [ blockCompleted wait ].! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'JT 6/16/2023 16:24:13' prior: 50664886!
runAndWaitAll: aCollectionOfBlocks

	| blockFinished numberOfBlocks |
	blockFinished := Semaphore new.
	numberOfBlocks := aCollectionOfBlocks size.
	
	aCollectionOfBlocks do: [:aBlock | [ aBlock value. blockFinished signal] fork ].
	
	numberOfBlocks timesRepeat: [ blockFinished wait ].! !
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:26:03' prior: 50664641!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	
	self runAndWaitAll: {
		[ totalSales := self totalSalesOf: anItem ].
		[ totalMoney := self totalMoneyRaisedBy: anItem ].
	}.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:26:14'!
PASSED!
!TusLibrosSystemFacade methodsFor: 'private' stamp: 'JT 6/16/2023 16:26:52' prior: 50664688!
storePerformance

	| totalMoney totalSales performance |
	
	performance := Dictionary new.
	
	self runAndWaitAll: {
		[ totalSales := self totalSales. ].
		[ totalMoney := self totalMoneyRaised. ].
	}.

	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!TusLibrosSystemFacade methodsFor: 'asynchronous jobs' stamp: 'JT 6/16/2023 16:27:25'!
runAsynchronouslyAndWaitAll: aCollectionOfBlocks

	| blockFinished numberOfBlocks |
	blockFinished := Semaphore new.
	numberOfBlocks := aCollectionOfBlocks size.
	
	aCollectionOfBlocks do: [:aBlock | [ aBlock value. blockFinished signal] fork ].
	
	numberOfBlocks timesRepeat: [ blockFinished wait ].! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'JT 6/16/2023 16:27:25' prior: 50664911!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	
	self runAsynchronouslyAndWaitAll: {
		[ totalSales := self totalSalesOf: anItem ].
		[ totalMoney := self totalMoneyRaisedBy: anItem ].
	}.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'JT 6/16/2023 16:27:25' prior: 50664934!
storePerformance

	| totalMoney totalSales performance |
	
	performance := Dictionary new.
	
	self runAsynchronouslyAndWaitAll: {
		[ totalSales := self totalSales. ].
		[ totalMoney := self totalMoneyRaised. ].
	}.

	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !

!methodRemoval: TusLibrosSystemFacade #runAndWaitAll: stamp: 'JT 6/16/2023 16:27:25'!
runAndWaitAll: aCollectionOfBlocks

	| blockFinished numberOfBlocks |
	blockFinished := Semaphore new.
	numberOfBlocks := aCollectionOfBlocks size.
	
	aCollectionOfBlocks do: [:aBlock | [ aBlock value. blockFinished signal] fork ].
	
	numberOfBlocks timesRepeat: [ blockFinished wait ].!
!TusLibrosSystemFacade methodsFor: 'asynchronous jobs' stamp: 'JT 6/16/2023 16:28:28'!
runAndWaitAll: aCollectionOfBlocks

	| blockFinished numberOfBlocks |
	blockFinished := Semaphore new.
	numberOfBlocks := aCollectionOfBlocks size.
	
	aCollectionOfBlocks do: [:aBlock | [ aBlock value. blockFinished signal] fork ].
	
	numberOfBlocks timesRepeat: [ blockFinished wait ].! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'JT 6/16/2023 16:28:28' prior: 50664985!
storePerformance

	| totalMoney totalSales performance |
	
	performance := Dictionary new.
	
	self runAndWaitAll: {
		[ totalSales := self totalSales. ].
		[ totalMoney := self totalMoneyRaised. ].
	}.

	performance at: 'quantity' put: totalSales.
	performance at: 'total' put: totalMoney.
	performance at: 'summary' put: 'The store selled a total of ',totalSales asString, ' books and raised a total amount of money equal to: ', totalMoney asString.
	
	^performance
	

! !
!TusLibrosSystemFacade methodsFor: 'as yet unclassified' stamp: 'JT 6/16/2023 16:28:28' prior: 50664965!
bookPerformance: anItem

	| bookPerformance totalMoney totalSales |

	bookPerformance := Dictionary new.
	
	self runAndWaitAll: {
		[ totalSales := self totalSalesOf: anItem ].
		[ totalMoney := self totalMoneyRaisedBy: anItem ].
	}.
	
	bookPerformance at: 'quantity' put: totalSales.
	bookPerformance at: 'total' put: totalMoney.
	bookPerformance at: 'summary' put: anItem,' was selled ',totalSales asString, ' times and raised a total amount of money equal to: ', totalMoney asString.
	
	^bookPerformance
	

! !

!methodRemoval: TusLibrosSystemFacade #runAsynchronouslyAndWaitAll: stamp: 'JT 6/16/2023 16:28:28'!
runAsynchronouslyAndWaitAll: aCollectionOfBlocks

	| blockFinished numberOfBlocks |
	blockFinished := Semaphore new.
	numberOfBlocks := aCollectionOfBlocks size.
	
	aCollectionOfBlocks do: [:aBlock | [ aBlock value. blockFinished signal] fork ].
	
	numberOfBlocks timesRepeat: [ blockFinished wait ].!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:28:38'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'JT 6/16/2023 16:28:50'!
PASSED!

----SNAPSHOT----(16 June 2023 16:29:38) TusLibros-it4.image priorSource: 10641150!

----STARTUP---- (19 June 2023 13:51:46) as /home/jt/files/cuis-university/images/TusLibros-it4.image!


2 printString !

2 printString!

!testRun: #CartTest #test01NewCartsAreCreatedEmpty stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CartTest #test02CanNotAddItemsThatDoNotBelongToStore stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CartTest #test03AfterAddingAnItemTheCartIsNotEmptyAnymore stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CartTest #test04CanNotAddNonPositiveNumberOfItems stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CartTest #test05CanNotAddMoreThanOneItemNotSellByTheStore stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CartTest #test06CartRemembersAddedItems stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CartTest #test07CartDoesNotHoldNotAddedItems stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CartTest #test08CartRemembersTheNumberOfAddedItems stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CashierTest #test01CanNotCheckoutAnEmptyCart stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CashierTest #test02CalculatedTotalIsCorrect stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CashierTest #test03CanNotCheckoutWithAnExpiredCreditCart stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CashierTest #test04CheckoutRegistersASale stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CashierTest #test05CashierChargesCreditCardUsingMerchantProcessor stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CashierTest #test06CashierDoesNotSaleWhenTheCreditCardHasNoCredit stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CreditCardTest #test01CreditCardNumberWithLessThan16DigitsIsNotValid stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CreditCardTest #test02CreditCardNumberWithMoreThan16DigitsIsNotValid stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CreditCardTest #test03CreditCardNumberShouldBeDigitsOnly stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CreditCardTest #test04NameCanNotBeEmpty stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CreditCardTest #test05IsExpiredOnNextExpirationMonth stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CreditCardTest #test06IsNotExpiredOnExpirationMonth stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #CreditCardTest #test07CanGetCreditCardInfoFromIt stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test01CanCreateCartWithValidUserAndPassword stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test02CanNotCreateCartWithInvalidUser stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test03CanNotCreateCartWithInvalidPassword stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test04CanAddItemsToACreatedCart stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test05CanNotAddItemToNotCreatedCart stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test06CanNotAddItemNotSellByTheStore stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test08CanNotListCartOfInvalidCartId stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test09ListCartReturnsTheRightNumberOfItems stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10CheckOutReturnsTransactionIdAndImpactsCustomerPurchases stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test10_1_CanNotCheckoutAnAlreadyCheckedOutCart stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test11CanNotCheckoutANotCreatedCart stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test12CanNotCheckoutAnEmptyCart stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test13CanNotCheckoutWithAnExpiredCreditCard stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test14ListPurchasesIncludesBoughtItems stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test15CanNotListPurchasesOfInvalidCustomer stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test16CanNotListPurchasesOfValidCustomerWithInvalidPassword stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test17CanNotAddToCartWhenSessionIsExpired stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test18CanNotListCartWhenSessionIsExpired stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test19CanNotCheckOutCartWhenSessionIsExpired stamp: 'JT 6/19/2023 17:28:55'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test20BookPerformanceShouldNotTakeTooLong stamp: 'JT 6/19/2023 17:28:56'!
PASSED!

!testRun: #TusLibrosSystemFacadeTest #test21StorePerformanceShouldNotTakeTooLong stamp: 'JT 6/19/2023 17:28:57'!
PASSED!

TusLibrosServerRestInterface installForDefaultSystem!

TusLibrosClientTestWindow open!

TusLibrosClientTestWindow !

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 17:40:02' prior: 50625846!
createCart

	| newCartId |
	
	[ newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived ] fork! !

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 17:44:28' prior: 50625833!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue: [
		[ cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId.
		self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId) ] fork
	]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 17:44:50' prior: 50625855!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		[ cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId.
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ] fork
	].! !

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 17:55:01' prior: 50665247!
createCart

	| newCartId |
	
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk'.
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'JT 6/19/2023 17:55:46' prior: 50625486!
build1stRow

	| createCartButtonMorph firstRowLayoutMorph |
	
	createCartButtonMorph := PluggableButtonMorph model: self stateGetter: nil  action: #createCart label: 'Create Cart'.	
	addToCartButtonMorph := PluggableButtonMorph model: self stateGetter: nil  action: #addToCart label: 'Add To Cart'.	
	
	firstRowLayoutMorph := LayoutMorph newRow.
	firstRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: createCartButtonMorph;
	addMorph: self build2ndColumn1stRow;
	addMorph: self build3rdColumn1stRow;
	addMorph:  addToCartButtonMorph.
	
	
	^firstRowLayoutMorph.! !
!TusLibrosClientTestWindow methodsFor: 'async model' stamp: 'JT 6/19/2023 17:56:00'!
asyncCreateCart

	self model createCart.! !
!TusLibrosClientTestWindow methodsFor: 'async model' stamp: 'JT 6/19/2023 17:56:03' prior: 50665315!
asyncCreateCart

	[ self model createCart ] fork.! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'JT 6/19/2023 17:56:16' prior: 50665294!
build1stRow

	| createCartButtonMorph firstRowLayoutMorph |
	
	createCartButtonMorph := PluggableButtonMorph model: self stateGetter: nil  action: #asyncCreateCart label: 'Create Cart'.	
	addToCartButtonMorph := PluggableButtonMorph model: self stateGetter: nil  action: #asyncAddToCart label: 'Add To Cart'.	
	
	firstRowLayoutMorph := LayoutMorph newRow.
	firstRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: createCartButtonMorph;
	addMorph: self build2ndColumn1stRow;
	addMorph: self build3rdColumn1stRow;
	addMorph:  addToCartButtonMorph.
	
	
	^firstRowLayoutMorph.! !
!TusLibrosClientTestWindow methodsFor: 'async model' stamp: 'JT 6/19/2023 17:56:33'!
asyncAddToCart

	[ self model addToCart ] fork.! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'JT 6/19/2023 17:57:06' prior: 50625560!
build2ndRow

	| secondRowLayoutMorph |

	listCartButtonMorph := PluggableButtonMorph model: self stateGetter: nil  action: #asyncListCart label: 'List CartId: '.	
	
	secondRowLayoutMorph := LayoutMorph newRow.
	secondRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: listCartButtonMorph;
	addMorph: self build2ndColumn2ndRow.
	
	^secondRowLayoutMorph

		! !
!TusLibrosClientTestWindow methodsFor: 'async model' stamp: 'JT 6/19/2023 17:57:32'!
asyncListCart

	[ self model listCart ] fork.! !

TusLibrosClientTestWindow open!

TusLibrosClientTestWindow open!

CurrentTusLibrosRestInterface !

WebServer reset!
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'JT 6/19/2023 18:06:29' prior: 50665325!
build1stRow

	| createCartButtonMorph firstRowLayoutMorph |
	
	createCartButtonMorph := PluggableButtonMorph model: self stateGetter: nil  action: #createCart label: 'Create Cart'.	
	addToCartButtonMorph := PluggableButtonMorph model: self stateGetter: nil  action: #addToCart label: 'Add To Cart'.	
	
	firstRowLayoutMorph := LayoutMorph newRow.
	firstRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: createCartButtonMorph;
	addMorph: self build2ndColumn1stRow;
	addMorph: self build3rdColumn1stRow;
	addMorph:  addToCartButtonMorph.
	
	
	^firstRowLayoutMorph.! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'JT 6/19/2023 18:06:35' prior: 50665352!
build2ndRow

	| secondRowLayoutMorph |

	listCartButtonMorph := PluggableButtonMorph model: self stateGetter: nil  action: #listCart label: 'List CartId: '.	
	
	secondRowLayoutMorph := LayoutMorph newRow.
	secondRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: listCartButtonMorph;
	addMorph: self build2ndColumn2ndRow.
	
	^secondRowLayoutMorph

		! !

!methodRemoval: TusLibrosClientTestWindow #asyncAddToCart stamp: 'JT 6/19/2023 18:06:38'!
asyncAddToCart

	[ self model addToCart ] fork.!

!methodRemoval: TusLibrosClientTestWindow #asyncCreateCart stamp: 'JT 6/19/2023 18:06:38'!
asyncCreateCart

	[ self model createCart ] fork.!

!methodRemoval: TusLibrosClientTestWindow #asyncListCart stamp: 'JT 6/19/2023 18:06:38'!
asyncListCart

	[ self model listCart ] fork.!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:07:58'!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:07:58' prior: 50665285!
createCart

	| newCartId |
	
	newCartId := restInterface createCartFor: 'hernan' password: 'smalltalk' andThen: [:aResult | aResult].
	cartIds add: newCartId.
	self triggerEvent: #newCartIdArrived! !

!methodRemoval: TusLibrosClientRestInterface #createCartFor:password: stamp: 'JT 6/19/2023 18:07:58'!
createCartFor: aUser password: aPassword

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:08:22' prior: 50665426!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
		ifFalse:[^self error: resp content]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:08:58' prior: 50665442!
createCart

	
	
	restInterface createCartFor: 'hernan' password: 'smalltalk' andThen: [:aResult | 
		cartIds add: aResult.
		self triggerEvent: #newCartIdArrived
	].! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:09:01' prior: 50665483!
createCart

	
	
	restInterface createCartFor: 'hernan' password: 'smalltalk' andThen: [:aResult | 
		cartIds add: aResult.
		self triggerEvent: #newCartIdArrived
	].! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:09:03' prior: 50665492!
createCart

	restInterface createCartFor: 'hernan' password: 'smalltalk' andThen: [:aResult | 
		cartIds add: aResult.
		self triggerEvent: #newCartIdArrived
	].! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:10:11'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:10:11' prior: 50665258!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue: [
		[ cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId andThen: [:aResult | aResult].
		self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId) ] fork
	]! !
!TusLibrosServerRestInterface methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:10:11' prior: 50625951!
addToCart: aRequest

	| bookIsbn cartId quantity |

	(Delay forSeconds: 3) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields.
		bookIsbn := self bookIsbnFrom: requestFields.
		quantity := self bookQuantityFrom: requestFields].
		
	self 
		answer: [
			systemFacade add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: [:aResult | aResult].
			'OK' ]
		to: aRequest 
	! !

!methodRemoval: TusLibrosClientRestInterface #add:of:toCartIdentifiedAs: stamp: 'JT 6/19/2023 18:10:11'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:10:20' prior: 50665509!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
		
	resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))]
		ifFalse:[^self error: resp content]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:12:57' prior: 50665526!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue: [
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId andThen: [:aResult |
			self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
		].
	]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:14:19'!
listCart: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
		ifFalse:[^self error: resp content]! !
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'JT 6/19/2023 18:14:19'!
listCart: aRequest andThen: aBlockThatUsesResult 

	| cartId |

	(Delay forSeconds: 10) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields ].
	
	self 
		answer: [(systemFacade listCartIdentifiedAs: cartId) asArray]
		to: aRequest 
! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:14:19' prior: 50665272!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		[ cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId andThen: [:aResult | aResult].
		self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId ] fork
	].! !
!TusLibrosServerRestInterface class methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:14:19' prior: 50626100!
installForDefaultSystem

	"self installForDefaultSystem"
	
	| server port interface |
	
	interface := self on: self defaultSystem.
	
	"Esto es para poder acceder a la interface de manera global - Hernan"
	Smalltalk at: #CurrentTusLibrosRestInterface put: interface.
	
	port := 9999.
	server := WebServer reset default.
	server listenOn: port.
	server 
		addService: '/createCart' 
		action: [:request | interface createCart: request ].
	server 
		addService: '/addToCart' 
		action: [:request | interface addToCart: request ].
	server
		addService: '/listCart' 
		action: [:request | interface listCart: request andThen: [:aResult | aResult] ].
	server
		addService: '/checkOutCart' 
		action: [:request | interface checkOutCart: request ].
	server
		addService: '/listPurchases' 
		action: [:request | interface listPurchases: request ].
	server useDebugErrorHandler ! !

!methodRemoval: TusLibrosClientRestInterface #listCart: stamp: 'JT 6/19/2023 18:14:19'!
listCart: cartId

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^(WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
		ifFalse:[^self error: resp content]!

!methodRemoval: TusLibrosServerRestInterface #listCart: stamp: 'JT 6/19/2023 18:14:20'!
listCart: aRequest

	| cartId |

	(Delay forSeconds: 10) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields ].
	
	self 
		answer: [(systemFacade listCartIdentifiedAs: cartId) asArray]
		to: aRequest 
!
!TusLibrosServerRestInterface class methodsFor: 'installation' stamp: 'JT 6/19/2023 18:14:49' prior: 50665645!
installForDefaultSystem

	"self installForDefaultSystem"
	
	| server port interface |
	
	interface := self on: self defaultSystem.
	
	"Esto es para poder acceder a la interface de manera global - Hernan"
	Smalltalk at: #CurrentTusLibrosRestInterface put: interface.
	
	port := 9999.
	server := WebServer reset default.
	server listenOn: port.
	server 
		addService: '/createCart' 
		action: [:request | interface createCart: request ].
	server 
		addService: '/addToCart' 
		action: [:request | interface addToCart: request ].
	server
		addService: '/listCart' 
		action: [:request | interface listCart: request ].
	server
		addService: '/checkOutCart' 
		action: [:request | interface checkOutCart: request ].
	server
		addService: '/listPurchases' 
		action: [:request | interface listPurchases: request ].
	server useDebugErrorHandler ! !
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'JT 6/19/2023 18:15:20'!
listCart: aRequest  

	| cartId |

	(Delay forSeconds: 10) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields ].
	
	self 
		answer: [(systemFacade listCartIdentifiedAs: cartId) asArray]
		to: aRequest 
! !

!methodRemoval: TusLibrosServerRestInterface #listCart:andThen: stamp: 'JT 6/19/2023 18:15:20'!
listCart: aRequest andThen: aBlockThatUsesResult 

	| cartId |

	(Delay forSeconds: 10) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields ].
	
	self 
		answer: [(systemFacade listCartIdentifiedAs: cartId) asArray]
		to: aRequest 
!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:16:21' prior: 50665605!
listCart: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
		
	resp isSuccess 
		ifTrue:[^ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
		ifFalse:[^self error: resp content]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:17:29' prior: 50665574!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[
				aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
			]
			ifFalse:[^self error: resp content]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:17:39' prior: 50665466!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
			ifFalse:[^self error: resp content]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:17:49' prior: 50665754!
listCart: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[^ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[^self error: resp content]
	] fork! !

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'JT 6/19/2023 18:18:26' prior: 50665376!
build1stRow

	| createCartButtonMorph firstRowLayoutMorph |
	
	createCartButtonMorph := PluggableButtonMorph model: self model stateGetter: nil  action: #createCart label: 'Create Cart'.	
	addToCartButtonMorph := PluggableButtonMorph model: self model stateGetter: nil  action: #addToCart label: 'Add To Cart'.	
	
	firstRowLayoutMorph := LayoutMorph newRow.
	firstRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: createCartButtonMorph;
	addMorph: self build2ndColumn1stRow;
	addMorph: self build3rdColumn1stRow;
	addMorph:  addToCartButtonMorph.
	
	
	^firstRowLayoutMorph.! !
!TusLibrosClientTestWindow methodsFor: 'GUI building' stamp: 'JT 6/19/2023 18:18:31' prior: 50665398!
build2ndRow

	| secondRowLayoutMorph |

	listCartButtonMorph := PluggableButtonMorph model: self model stateGetter: nil  action: #listCart label: 'List CartId: '.	
	
	secondRowLayoutMorph := LayoutMorph newRow.
	secondRowLayoutMorph separation: 25;
	axisEdgeWeight: 0.5;
	addMorph: listCartButtonMorph;
	addMorph: self build2ndColumn2ndRow.
	
	^secondRowLayoutMorph

		! !

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:20:39' prior: 50665632!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		currentSelectedCartContent := restInterface listCart: cartId andThen: [:aResult |
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
		].
	].! !

TusLibrosClientTestWindow open!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:22:28' prior: 50665862!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		 restInterface listCart: cartId andThen: [:aResult |
			currentSelectedCartContent := aResult.
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
		].
	].! !

TusLibrosClientTestWindow open!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:23:48' prior: 50665788!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
			ifFalse:[ self error: resp content]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:23:54' prior: 50665805!
listCart: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[ self error: resp content]
	] fork! !

TusLibrosClientTestWindow open!
!TusLibrosServerRestInterface methodsFor: 'rest interface' stamp: 'JT 6/19/2023 18:26:33' prior: 50665541!
addToCart: aRequest

	| bookIsbn cartId quantity |

	(Delay forSeconds: 3) wait.
	
	self withFieldsOf: aRequest do: [ :requestFields |
		cartId := self cartIdFrom: requestFields.
		bookIsbn := self bookIsbnFrom: requestFields.
		quantity := self bookQuantityFrom: requestFields].
		
	self 
		answer: [
			systemFacade add: quantity of: bookIsbn toCartIdentifiedAs: cartId.
			'OK' ]
		to: aRequest 
	! !

TusLibrosClientTestWindow open !

WebServer reset!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:31:19'!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
			ifFalse:[ self error: resp content]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:31:19' prior: 50665501!
createCart

	restInterface createCartFor: 'hernan' password: 'smalltalk' andThen: [:aResult | 
		cartIds add: aResult.
		self triggerEvent: #newCartIdArrived
	] withHandler: [:anError | self error: anError].! !

!methodRemoval: TusLibrosClientRestInterface #createCartFor:password:andThen: stamp: 'JT 6/19/2023 18:31:19'!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
			ifFalse:[ self error: resp content]
	] fork!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:32:17'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[
				aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
			]
			ifFalse:[^self error: resp content]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:32:17' prior: 50665592!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue: [
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId andThen: [:aResult |
			self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
		] withHandler: [:anError | self error: anError].
	]! !

!methodRemoval: TusLibrosClientRestInterface #add:of:toCartIdentifiedAs:andThen: stamp: 'JT 6/19/2023 18:32:17'!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[
				aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
			]
			ifFalse:[^self error: resp content]
	] fork!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:32:43'!
listCart: cartId andWithItems: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[ self error: resp content]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:32:43' prior: 50665875!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		 restInterface listCart: cartId andWithItems: [:aResult |
			currentSelectedCartContent := aResult.
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
		].
	].! !

!methodRemoval: TusLibrosClientRestInterface #listCart:andThen: stamp: 'JT 6/19/2023 18:32:43'!
listCart: cartId andThen: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[ self error: resp content]
	] fork!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:33:08'!
listCart: cartId andWithItems: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[ self error: resp content]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'as yet unclassified' stamp: 'JT 6/19/2023 18:33:08' prior: 50666053!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		 restInterface listCart: cartId andWithItems: [:aResult |
			currentSelectedCartContent := aResult.
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
		] withHandler: [:anError | self error: anError].
	].! !

!methodRemoval: TusLibrosClientRestInterface #listCart:andWithItems: stamp: 'JT 6/19/2023 18:33:08'!
listCart: cartId andWithItems: aBlockThatUsesResult 

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[ self error: resp content]
	] fork!
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:33:27' prior: 50666003!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue: [
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId andThen: [:aResult |
			self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
		] withHandler: [:anErrorMessage | self error: anErrorMessage].
	]! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:36:03' prior: 50665939!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
		resp isSuccess 
			ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
			ifFalse:[ anErrorHandler value: resp content]
	] fork! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:36:27' prior: 50665957!
createCart

	restInterface createCartFor: 'hernan' password: 'smalltalk' andThen: [:aResult | 
		cartIds add: aResult.
		self triggerEvent: #newCartIdArrived
	] withHandler: [:anErrorMessage | self error: anErrorMessage].! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:36:34' prior: 50666098!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		 restInterface listCart: cartId andWithItems: [:aResult |
			currentSelectedCartContent := aResult.
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
		] withHandler: [:anErrorMessage | self error: anErrorMessage].
	].! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:43:06' prior: 50666162!
createCart

	restInterface createCartFor: 'hernan' password: 'smalltalk' andThen: [:aResult | 
		cartIds add: aResult.
		self triggerEvent: #newCartIdArrived
	] withHandler: [:anErrorMessage |
		self triggerEvent: #interfaceError with: anErrorMessage
	].! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:43:16' prior: 50666128!
addToCart

	| cartId bookIsbn |

	(self areCartIdAndBookSelected) ifTrue: [
		cartId := self selectedCartId.
		bookIsbn := self selectedBook.
		restInterface add: 1 of: bookIsbn toCartIdentifiedAs: cartId andThen: [:aResult |
			self triggerEvent: #bookAddedToCart withArguments: (Array with: bookIsbn with: cartId)
		] withHandler: [:anErrorMessage |
			self triggerEvent: #interfaceError with: anErrorMessage
		].
	]! !
!TusLibrosClientTestWindowModel methodsFor: 'buttonSelectors' stamp: 'JT 6/19/2023 18:43:25' prior: 50666173!
listCart

	| cartId |
	
	(self isCartIdSelected) ifTrue:[
		cartId := self selectedCartId.
		 restInterface listCart: cartId andWithItems: [:aResult |
			currentSelectedCartContent := aResult.
			self triggerEvent: #newCurrentSelectedCartContentArrived with: cartId
		] withHandler: [:anErrorMessage |
			self triggerEvent: #interfaceError with: anErrorMessage
		].
	].! !
!TusLibrosClientTestWindow methodsFor: 'initialization' stamp: 'JT 6/19/2023 18:43:56' prior: 50625614!
initializeWith: aTitle

	self setLabel: aTitle.
	self model: (TusLibrosClientTestWindowModel new).
	self morphExtent: (self defaultExtent).
	self buildMorphicWindow.
	self openInWorld.
			
	self model when: #newCartIdArrived send: #refreshListOfCartIds to: self.		
	self model when: #selectedCartChanged send: #refreshCartButtonsLabels: to: self.	
	self model when: #bookAddedToCart send: #informBook:addedToCart: to: self.
	self model when: #newCurrentSelectedCartContentArrived send: #refreshCurrentSelectedCartContent: to: self.
	self model when: #interfaceError send: #showErrorMessage to: self.! !
!TusLibrosClientTestWindow methodsFor: 'events' stamp: 'JT 6/19/2023 18:46:37'!
showErrorMessage: anErrorMessage

	self inform: anErrorMessage! !

WebServer reset!

TusLibrosClientTestWindow open!

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosClientTestWindow open!

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:50:19' prior: 50666144!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
			resp isSuccess 
				ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
				ifFalse:[ anErrorHandler value: resp content].
		] ensure: [:anError | anErrorHandler value: anError messageText].
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:51:15' prior: 50666265!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		] ensure: [:anError | anErrorHandler value: anError messageText].
			
			resp isSuccess 
				ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
				ifFalse:[ anErrorHandler value: resp content].
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:51:31' prior: 50665983!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		] ensure: [:anError | anErrorHandler value: anError messageText].
			
		resp isSuccess 
			ifTrue:[
				aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
			]
			ifFalse:[^self error: resp content]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:51:46' prior: 50666080!
listCart: cartId andWithItems: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
		] ensure: [:anError | anErrorHandler value: anError messageText].
			
		resp isSuccess 
			ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[ self error: resp content]
	] fork! !

WebServer reset!

TusLibrosServerRestInterface installForDefaultSystem !

TusLibrosClientTestWindow open!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:54:41' prior: 50666307!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
			
		resp isSuccess 
			ifTrue:[
				aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
			]
			ifFalse:[^self error: resp content]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:54:49' prior: 50666286!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
			
			resp isSuccess 
				ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
				ifFalse:[ anErrorHandler value: resp content].
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:54:58' prior: 50666328!
listCart: cartId andWithItems: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
			
		resp isSuccess 
			ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[ self error: resp content]
	] fork! !

TusLibrosClientTestWindow open!

WebServer reset!
!TusLibrosClientTestWindow methodsFor: 'initialization' stamp: 'JT 6/19/2023 18:56:07' prior: 50666231!
initializeWith: aTitle

	self setLabel: aTitle.
	self model: (TusLibrosClientTestWindowModel new).
	self morphExtent: (self defaultExtent).
	self buildMorphicWindow.
	self openInWorld.
			
	self model when: #newCartIdArrived send: #refreshListOfCartIds to: self.		
	self model when: #selectedCartChanged send: #refreshCartButtonsLabels: to: self.	
	self model when: #bookAddedToCart send: #informBook:addedToCart: to: self.
	self model when: #newCurrentSelectedCartContentArrived send: #refreshCurrentSelectedCartContent: to: self.
	self model when: #interfaceError send: #showErrorMessage: to: self.! !

TusLibrosClientTestWindow open!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:57:50' prior: 50666351!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
		] on: Error do: [:anError | anErrorHandler value: anError messageText. ^ self].
			
		resp isSuccess 
			ifTrue:[
				aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
			]
			ifFalse:[^self error: resp content]
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:57:56' prior: 50666373!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
		] on: Error do: [:anError | anErrorHandler value: anError messageText. ^ self].
			
			resp isSuccess 
				ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
				ifFalse:[ anErrorHandler value: resp content].
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:58:01' prior: 50666394!
listCart: cartId andWithItems: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
		] on: Error do: [:anError | anErrorHandler value: anError messageText. ^ self].
			
		resp isSuccess 
			ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
			ifFalse:[ self error: resp content]
	] fork! !

TusLibrosClientTestWindow open!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:58:34' prior: 50666439!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/addToCart') fields: fieldDict.
			
			resp isSuccess 
				ifTrue:[
					aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
				]
				ifFalse:[^self error: resp content]
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:58:44' prior: 50666461!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/createCart') fields: fieldDict.
			
			resp isSuccess 
				ifTrue: [ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))] 
				ifFalse:[ anErrorHandler value: resp content].
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 18:58:55' prior: 50666482!
listCart: cartId andWithItems: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict resp |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	[
		[
			resp := WebClient htmlSubmit: (self url,'/listCart') fields: fieldDict.
			
			resp isSuccess 
				ifTrue:[ aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream)) asOrderedCollection] 
				ifFalse:[ self error: resp content]
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
	] fork! !

TusLibrosClientTestWindow open!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:01:35'!
asyncRequestTo: aLocation andThen: aBlockThatUsesResult withHandler: anErrorHandler

	| resp |
	resp := WebClient.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:02:22'!
asyncRequestTo: aLocation withFields: aFieldsDictionary andThen: aBlockThatUsesResult withHandler: anErrorHandler

	| resp |
	[
		[
			resp := WebClient htmlSubmit: (self url , aLocation) fields: aFieldsDictionary.
			
			resp isSuccess 
				ifTrue:[
					aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
				]
				ifFalse:[^self error: resp content]
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
	] fork! !

!methodRemoval: TusLibrosClientRestInterface #asyncRequestTo:andThen:withHandler: stamp: 'JT 6/19/2023 19:02:25'!
asyncRequestTo: aLocation andThen: aBlockThatUsesResult withHandler: anErrorHandler

	| resp |
	resp := WebClient.!
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:03:10' prior: 50666503!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self asyncRequestTo: '/addToCart' withFields: fieldDict andThen: aBlockThatUsesResult withHandler: anErrorHandler.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:03:28' prior: 50666525!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	self asyncRequestTo: '/createCart' withFields: fieldDict andThen: aBlockThatUsesResult withHandler: anErrorHandler.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:04:05' prior: 50666546!
listCart: cartId andWithItems: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. }.		
	
	self asyncRequestTo: '/listCart'
		 withFields: fieldDict
		 andThen: [:aResult | aBlockThatUsesResult value: aResult asOrderedCollection]
		 withHandler: anErrorHandler.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:04:14' prior: 50666613!
createCartFor: aUser password: aPassword andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict |
	
	fieldDict := Dictionary newFromPairs: {'clientId'. aUser. 'password'. aPassword}.		
	
	self asyncRequestTo: '/createCart'
		 withFields: fieldDict
		 andThen: aBlockThatUsesResult
		 withHandler: anErrorHandler.! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:04:22' prior: 50666598!
add: quantity of: bookIsbn toCartIdentifiedAs: cartId andThen: aBlockThatUsesResult withHandler: anErrorHandler  

	| fieldDict |

	fieldDict := Dictionary newFromPairs: {'cartId'. cartId. 'bookIsbn'. bookIsbn. 'bookQuantity'. quantity}.		
	
	self asyncRequestTo: '/addToCart'
		 withFields: fieldDict
		 andThen: aBlockThatUsesResult
		 withHandler: anErrorHandler.! !

TusLibrosClientTestWindow open!

TusLibrosServerRestInterface installForDefaultSystem !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:06:02' prior: 50666573!
asyncRequestTo: aLocation withFields: aFieldsDictionary andThen: aBlockThatUsesResult withHandler: anErrorHandler

	[
		[ | resp |
			resp := WebClient htmlSubmit: (self url , aLocation) fields: aFieldsDictionary.
			
			resp isSuccess 
				ifTrue:[
					aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
				]
				ifFalse:[^self error: resp content]
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
	] fork! !
!TusLibrosClientRestInterface methodsFor: 'requests' stamp: 'JT 6/19/2023 19:07:45' prior: 50666673!
asyncRequestTo: aLocation withFields: aFieldsDictionary andThen: aBlockThatUsesResult withHandler: anErrorHandler

	[
		[ | resp |
			resp := WebClient htmlSubmit: (self url , aLocation) fields: aFieldsDictionary.
			
			resp isSuccess 
				ifTrue:[
					aBlockThatUsesResult value: (WebUtils jsonDecode: ((resp content) readStream))
				]
				ifFalse:[anErrorHandler value: resp content]
		] on: Error do: [:anError | anErrorHandler value: anError messageText].
	] fork! !

----SNAPSHOT----(19 June 2023 19:11:04) TusLibros-it4.image priorSource: 10669927!

----SNAPSHOT----(19 June 2023 19:12:32) TusLibros-it4.image priorSource: 10721849!

----QUIT----(19 June 2023 19:12:36) TusLibros-it4.image priorSource: 10721933!